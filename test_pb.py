import unittest
import pytest

import pb

# Fixtures we can use to compare our library against golden bits generated by
# the official Google protobuf library.

CASES = []


"""
# Simple case.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > simple.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Simple {
  uint64 id = 1;
  string name = 2;
  bytes raw = 3;
  sint64 score = 4;
  fixed32 a32 = 5;
  fixed64 a64 = 6;
}
PROTO
protoc --python_out=. simple.proto
python3 - <<'PY'
import simple_pb2
m = simple_pb2.Simple(id=7, name="ok", raw=b"xy", score=-5, a32=123, a64=456)
b = m.SerializeToString()
print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')
PY
"""
c = {}
c["name"] = "simple"
c["proto"] = '''
syntax = "proto3";
package testpb;
message Simple {
  uint64 id = 1;
  string name = 2;
  bytes raw = 3;
  sint64 score = 4;
  fixed32 a32 = 5;
  fixed64 a64 = 6;
}
'''.strip()
c["schema"] = [
    ("varint", "id", 1),
    ("string", "name", 2),
    ("bytes", "raw", 3),
    ("sint", "score", 4),
    ("fixed32", "a32", 5),
    ("fixed64", "a64", 6),
]
c["blob"] = b"\x08\x07\x12\x02\x6f\x6b\x1a\x02\x78\x79\x20\x09\x2d\x7b\x00\x00\x00\x31\xc8\x01\x00\x00\x00\x00\x00\x00"
c["values"] = {
    "id": 7,
    "name": "ok",
    "raw": b"xy",
    "score": -5,
    "a32": 123,
    "a64": 456,
}
CASES.append(c)

"""
# Signed fixed singletons: sfixed32 and sfixed64

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > signed_fixed.proto <<'PROTO'
syntax = "proto3";
package testpb;
message SignedFixed {
  sfixed32 a = 1;
  sfixed64 b = 2;
}
PROTO
protoc --python_out=. signed_fixed.proto
python3 - <<'PY'
import signed_fixed_pb2
m = signed_fixed_pb2.SignedFixed(a=-2, b=-3)
b = m.SerializeToString()
print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')
PY
"""
c = {}
c["name"] = "signed_fixed_singletons"
c["proto"] = '''
syntax = "proto3";
package testpb;
message SignedFixed {
  sfixed32 a = 1;
  sfixed64 b = 2;
}
'''.strip()
c["schema"] = [
    ("sfixed32", "a", 1),
    ("sfixed64", "b", 2),
]
# field 1 (wt=5): 0x0d, -2 => fe ff ff ff
# field 2 (wt=1): 0x11, -3 => fd ff ff ff ff ff ff ff
c["blob"] = b"\x0d\xfe\xff\xff\xff\x11\xfd\xff\xff\xff\xff\xff\xff\xff"
c["values"] = {
    "a": -2,
    "b": -3,
}
CASES.append(c)

"""
# Packed signed fixed: repeated sfixed32 and sfixed64

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > packed_signed_fixed.proto <<'PROTO'
syntax = "proto3";
package testpb;
message PackedSignedFixed {
  repeated sfixed32 a = 1;
  repeated sfixed64 b = 2;
}
PROTO
protoc --python_out=. packed_signed_fixed.proto
python3 - <<'PY'
import packed_signed_fixed_pb2
vals_a = [-1, 0, 1, 0x7fffffff, -2147483648]
vals_b = [-1, -2, 0, 1, 0x7fffffffffffffff, -9223372036854775808]
m = packed_signed_fixed_pb2.PackedSignedFixed(a=vals_a, b=vals_b)
b = m.SerializeToString()
print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')
PY
"""
c = {}
c["name"] = "packed_signed_fixed"
c["proto"] = '''
syntax = "proto3";
package testpb;
message PackedSignedFixed {
  repeated sfixed32 a = 1;
  repeated sfixed64 b = 2;
}
'''.strip()
c["schema"] = [
    ("repeated", "a", 1, "sfixed32"),
    ("repeated", "b", 2, "sfixed64"),
]
# a: [-1,0,1,0x7fffffff,-2147483648]
# tag=0x0a, len=0x14, payload=
#   ff ff ff ff | 00 00 00 00 | 01 00 00 00 | ff ff ff 7f | 00 00 00 80
# b: [-1,-2,0,1,0x7fffffffffffffff,-9223372036854775808]
# tag=0x12, len=0x30, payload=
#   ff*8 | fe ff ff ff ff ff ff ff | 00*8 | 01 00*7 | ff*7 7f | 00*7 80
c["blob"] = b"\x0a\x14\xff\xff\xff\xff\x00\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\x7f\x00\x00\x00\x80\x12\x30\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\x7f\x00\x00\x00\x00\x00\x00\x00\x80"
c["values"] = {
    "a": [-1, 0, 1, 0x7fffffff, -2147483648],
    "b": [-1, -2, 0, 1, 0x7fffffffffffffff, -9223372036854775808],
}
CASES.append(c)


"""
# oneof parity for individual selections and decode last-wins.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > oneof.proto <<'PROTO'
syntax = "proto3";
package testpb;
message OneOfMsg {
  oneof choice {
    uint64 a = 1;
    string s = 2;
    bytes b = 3;
  }
  uint64 tail = 4;
}
PROTO
protoc --python_out=. oneof.proto
python3 - <<'PY'
import oneof_pb2
m1 = oneof_pb2.OneOfMsg(a=7, tail=1)
print('A:', 'b"' + ''.join(f'\\x{c:02x}' for c in m1.SerializeToString()) + '"')
m2 = oneof_pb2.OneOfMsg(s='ok', tail=1)
print('S:', 'b"' + ''.join(f'\\x{c:02x}' for c in m2.SerializeToString()) + '"')
w = oneof_pb2.OneOfMsg(a=7).SerializeToString() + oneof_pb2.OneOfMsg(s='ok').SerializeToString() + oneof_pb2.OneOfMsg(tail=1).SerializeToString()
print('W:', 'b"' + ''.join(f'\\x{c:02x}' for c in w) + '"')
PY
"""
ONEOF_SCHEMA = [
    ("oneof", "choice", [
        ("varint", "a", 1),
        ("string", "s", 2),
        ("bytes", "b", 3),
    ]),
    ("varint", "tail", 4),
]

c = {}
c["name"] = "oneof_a"
c["proto"] = 'oneof OneOfMsg { a|s|b; } with tail'
c["schema"] = ONEOF_SCHEMA
c["blob"] = b"\x08\x07\x20\x01"
c["values"] = {"a": 7, "tail": 1}
CASES.append(c)

c = {}
c["name"] = "oneof_s"
c["proto"] = 'oneof OneOfMsg { a|s|b; } with tail'
c["schema"] = ONEOF_SCHEMA
c["blob"] = b"\x12\x02\x6f\x6b\x20\x01"
c["values"] = {"s": "ok", "tail": 1}
CASES.append(c)


def test_oneof_decode_last_wins_from_concatenated_wire():
    #
    # Arrange
    #
    wire = b"\x08\x07\x12\x02\x6f\x6b\x20\x01"

    #
    # Act
    #
    dec = pb.decode(wire, ONEOF_SCHEMA)

    #
    # Assert
    #
    assert dec == {"s": "ok", "tail": 1}


def test_oneof_encode_multiple_fields_raises_valueerror():
    #
    # Arrange
    #
    vals = {"a": 7, "s": "ok", "tail": 1}

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.encode(vals, ONEOF_SCHEMA)

"""
# Basic types coverage: bool, int32/64, uint32/64, float, double, sint32/64.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > basic_types.proto <<'PROTO'
syntax = "proto3";
package testpb;
message BasicTypes {
  bool b1 = 1;
  bool b2 = 2;
  int32 i32 = 3;
  int64 i64 = 4;
  uint32 u32 = 5;
  uint64 u64 = 6;
  float f = 7;
  double d = 8;
  sint32 s32 = 9;
  sint64 s64 = 10;
}
PROTO
protoc --python_out=. basic_types.proto
python3 - <<'PY'
import basic_types_pb2
m = basic_types_pb2.BasicTypes(
    b1=True,
    b2=False,
    i32=-1,
    i64=-2,
    u32=0xffffffff,
    u64=0xffffffffffffffff,
    f=1.5,
    d=-2.25,
    s32=-12345,
    s64=-67890,
)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "basic_types"
c["proto"] = '''
syntax = "proto3";
package testpb;
message BasicTypes {
  bool b1 = 1;
  bool b2 = 2;
  int32 i32 = 3;
  int64 i64 = 4;
  uint32 u32 = 5;
  uint64 u64 = 6;
  float f = 7;
  double d = 8;
  sint32 s32 = 9;
  sint64 s64 = 10;
}
'''.strip()
c["schema"] = [
    ("bool", "b1", 1),
    ("bool", "b2", 2),
    ("int32", "i32", 3),
    ("int64", "i64", 4),
    ("uint32", "u32", 5),
    ("uint64", "u64", 6),
    ("float", "f", 7),
    ("double", "d", 8),
    ("sint32", "s32", 9),
    ("sint", "s64", 10),
]
c["blob"] = b"\x08\x01\x18\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x20\xfe\xff\xff\xff\xff\xff\xff\xff\xff\x01\x28\xff\xff\xff\xff\x0f\x30\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3d\x00\x00\xc0\x3f\x41\x00\x00\x00\x00\x00\x00\x02\xc0\x48\xf1\xc0\x01\x50\xe3\xa4\x08"
c["values"] = {
    # b2 is omitted (default false) to match official encoding omissions
    "b1": True,
    "i32": -1,
    "i64": -2,
    "u32": 0xFFFFFFFF,
    "u64": 0xFFFFFFFFFFFFFFFF,
    "f": 1.5,
    "d": -2.25,
    "s32": -12345,
    "s64": -67890,
}
CASES.append(c)

"""
# Empty embedded message present (zero-length message); parity encode/decode.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > empty_msg.proto <<'PROTO'
syntax = "proto3";
package testpb;
message EmptyInner {}
message Container { EmptyInner e = 1; }
PROTO
protoc --python_out=. empty_msg.proto
python3 - <<'PY'
import empty_msg_pb2
m = empty_msg_pb2.Container(e=empty_msg_pb2.EmptyInner())
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "empty_embedded_message"
c["proto"] = '''
syntax = "proto3";
package testpb;
message EmptyInner {}
message Container { EmptyInner e = 1; }
'''.strip()
c["schema"] = [ ([ ], "e", 1) ]
c["blob"] = b"\x0a\x00"
c["values"] = {"e": {}}
CASES.append(c)

"""
# Zigzag singletons: cover negative/zero/positive and larger magnitudes.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > zigzag_np.proto <<'PROTO'
syntax = "proto3";
package testpb;
message ZigzagNP {
  sint64 s1 = 1;
  sint64 s2 = 2;
  sint64 s3 = 3;
  sint64 s4 = 4;
  sint64 s5 = 5;
  sint64 big1 = 6;
  sint64 big2 = 7;
}
PROTO
protoc --python_out=. zigzag_np.proto
python3 - <<'PY'
import zigzag_np_pb2
m = zigzag_np_pb2.ZigzagNP(s1=-2, s2=-1, s3=0, s4=1, s5=2, big1=-123456789, big2=987654321)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "zigzag_singletons"
c["proto"] = '''
syntax = "proto3";
package testpb;
message ZigzagNP {
  sint64 s1 = 1;
  sint64 s2 = 2;
  sint64 s3 = 3;
  sint64 s4 = 4;
  sint64 s5 = 5;
  sint64 big1 = 6;
  sint64 big2 = 7;
}
'''.strip()
c["schema"] = [
    ("sint", "s1", 1),
    ("sint", "s2", 2),
    ("sint", "s3", 3),
    ("sint", "s4", 4),
    ("sint", "s5", 5),
    ("sint", "big1", 6),
    ("sint", "big2", 7),
]
# Note: proto3 omits default 0 for s3 on the wire; keep values dict free of s3.
c["blob"] = b"\x08\x03\x10\x01\x20\x02\x28\x04\x30\xa9\xb4\xde\x75\x38\xe2\xa2\xf3\xad\x07"
c["values"] = {
    "s1": -2,
    "s2": -1,
    # "s3": 0,  # omitted in official bytes (default)
    "s4": 1,
    "s5": 2,
    "big1": -123456789,
    "big2": 987654321,
}
CASES.append(c)


"""
# Zigzag packed: repeated sint64 with a small table and larger magnitudes.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > zigzag_packed.proto <<'PROTO'
syntax = "proto3";
package testpb;
message ZigzagPacked { repeated sint64 nums = 1; }
PROTO
protoc --python_out=. zigzag_packed.proto
python3 - <<'PY'
import zigzag_packed_pb2
vals = [-2, -1, 0, 1, 2, -123456789, 987654321]
m = zigzag_packed_pb2.ZigzagPacked(nums=vals)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "zigzag_packed"
c["proto"] = '''
syntax = "proto3";
package testpb;
message ZigzagPacked { repeated sint64 nums = 1; }
'''.strip()
c["schema"] = [("repeated", "nums", 1, "sint")]
c["blob"] = b"\x0a\x0e\x03\x01\x00\x02\x04\xa9\xb4\xde\x75\xe2\xa2\xf3\xad\x07"
c["values"] = {
    "nums": [-2, -1, 0, 1, 2, -123456789, 987654321]
}
CASES.append(c)

"""
# Varint boundaries and mid-range checks

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > varint_bounds.proto <<'PROTO'
syntax = "proto3";
package testpb;
message VarintBounds { uint64 a = 1; uint64 b = 2; uint64 c = 3; uint64 d = 4; }
PROTO
protoc --python_out=. varint_bounds.proto
python3 - <<'PY'
import varint_bounds_pb2
m = varint_bounds_pb2.VarintBounds(a=127, b=128, c=300, d=16384)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "varint_boundaries"
c["proto"] = '''
syntax = "proto3";
package testpb;
message VarintBounds { uint64 a = 1; uint64 b = 2; uint64 c = 3; uint64 d = 4; }
'''.strip()
c["schema"] = [("varint", "a", 1), ("varint", "b", 2), ("varint", "c", 3), ("varint", "d", 4)]
c["blob"] = b"\x08\x7f\x10\x80\x01\x18\xac\x02\x20\x80\x80\x01"
c["values"] = {"a": 127, "b": 128, "c": 300, "d": 16384}
CASES.append(c)

"""
# Mixed encode keys: numeric tags + names should encode identically.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > mixed_keys.proto <<'PROTO'
syntax = "proto3";
package testpb;
message MixedKeys { uint64 id = 1; string name = 2; bytes raw = 3; }
PROTO
protoc --python_out=. mixed_keys.proto
python3 - <<'PY'
import mixed_keys_pb2
m = mixed_keys_pb2.MixedKeys(id=7, name="ok", raw=b"xy")
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "mixed_keys_base"
c["proto"] = '''
syntax = "proto3";
package testpb;
message MixedKeys { uint64 id = 1; string name = 2; bytes raw = 3; }
'''.strip()
c["schema"] = [
    ("varint", "id", 1),
    ("string", "name", 2),
    ("bytes", "raw", 3),
]
c["blob"] = b"\x08\x07\x12\x02\x6f\x6b\x1a\x02\x78\x79"
c["values"] = {"id": 7, "name": "ok", "raw": b"xy"}
CASES.append(c)


"""
# Recursive (direct): Node contains Node child; finite chain depth 3.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > recursive_node.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Node { uint64 id = 1; Node child = 2; }
message Root { Node head = 1; }
PROTO
protoc --python_out=. recursive_node.proto
python3 - <<'PY'
import recursive_node_pb2
n3 = recursive_node_pb2.Node(id=3)
n2 = recursive_node_pb2.Node(id=2, child=n3)
n1 = recursive_node_pb2.Node(id=1, child=n2)
m = recursive_node_pb2.Root(head=n1)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
# Build normalized self-referential schema dicts
# Note: We intentionally use the already-normalized schema dict form here
# because tuple-based schemas are not cycle-safe during normalization.
# pb.encode/pb.decode accept either a list of tuples (acyclic)
# or a normalized dict with keys 'fields' and 'names'. The dict form enables
# expressing recursion safely by pointing a message field's 'schema' to the
# same dict.
_NODE_SCHEMA = {"fields": {}, "names": {}}
_NODE_SCHEMA["fields"][1] = {"kind": "scalar", "type": "varint", "name": "id"}
_NODE_SCHEMA["names"]["id"] = 1
_NODE_SCHEMA["fields"][2] = {"kind": "message", "schema": _NODE_SCHEMA, "name": "child"}
_NODE_SCHEMA["names"]["child"] = 2
_ROOT_SCHEMA = {"fields": {1: {"kind": "message", "schema": _NODE_SCHEMA, "name": "head"}}, "names": {"head": 1}}

c = {}
c["name"] = "recursive_direct"
c["proto"] = '''
syntax = "proto3";
package testpb;
message Node { uint64 id = 1; Node child = 2; }
message Root { Node head = 1; }
'''.strip()
c["schema"] = _ROOT_SCHEMA
c["blob"] = b"\x0a\x0a\x08\x01\x12\x06\x08\x02\x12\x02\x08\x03"
c["values"] = {"head": {"id": 1, "child": {"id": 2, "child": {"id": 3}}}}
CASES.append(c)


"""
# Recursive (indirect): A has B; B has A; finite chain depth 3.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > recursive_indirect.proto <<'PROTO'
syntax = "proto3";
package testpb;
message A { uint64 id = 1; B b = 2; }
message B { uint64 id = 1; A a = 2; }
message Wrap { A a = 1; }
PROTO
protoc --python_out=. recursive_indirect.proto
python3 - <<'PY'
import recursive_indirect_pb2
a3 = recursive_indirect_pb2.A(id=3)
b2 = recursive_indirect_pb2.B(id=2, a=a3)
a1 = recursive_indirect_pb2.A(id=1, b=b2)
m = recursive_indirect_pb2.Wrap(a=a1)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
# Build normalized mutually-referential schema dicts
# Same rationale as above: dict schemas allow safe cycles (A↔B) by reference.
_A_SCHEMA = {"fields": {}, "names": {}}
_B_SCHEMA = {"fields": {}, "names": {}}
_A_SCHEMA["fields"][1] = {"kind": "scalar", "type": "varint", "name": "id"}
_A_SCHEMA["names"]["id"] = 1
_A_SCHEMA["fields"][2] = {"kind": "message", "schema": _B_SCHEMA, "name": "b"}
_A_SCHEMA["names"]["b"] = 2
_B_SCHEMA["fields"][1] = {"kind": "scalar", "type": "varint", "name": "id"}
_B_SCHEMA["names"]["id"] = 1
_B_SCHEMA["fields"][2] = {"kind": "message", "schema": _A_SCHEMA, "name": "a"}
_B_SCHEMA["names"]["a"] = 2
_WRAP_SCHEMA = {"fields": {1: {"kind": "message", "schema": _A_SCHEMA, "name": "a"}}, "names": {"a": 1}}

c = {}
c["name"] = "recursive_indirect"
c["proto"] = '''
syntax = "proto3";
package testpb;
message A { uint64 id = 1; B b = 2; }
message B { uint64 id = 1; A a = 2; }
message Wrap { A a = 1; }
'''.strip()
c["schema"] = _WRAP_SCHEMA
c["blob"] = b"\x0a\x0a\x08\x01\x12\x06\x08\x02\x12\x02\x08\x03"
c["values"] = {"a": {"id": 1, "b": {"id": 2, "a": {"id": 3}}}}
CASES.append(c)

"""
# Outer/Inner nested case.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > outer.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Inner { sint64 x = 1; fixed32 y = 2; }
message Outer { Inner inner = 1; }
PROTO
protoc --python_out=. outer.proto
python3 - <<'PY'
import outer_pb2
m = outer_pb2.Outer(inner=outer_pb2.Inner(x=-5, y=123))
b = m.SerializeToString()
print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')
PY
"""
c = {}
c["name"] = "outer_inner"
c["proto"] = '''
syntax = "proto3";
package testpb;
message Inner {
  sint64 x = 1;
  fixed32 y = 2;
}
message Outer {
  Inner inner = 1;
}
'''.strip()
c["schema"] = [
    ([
        ("sint", "x", 1),
        ("fixed32", "y", 2),
    ], "inner", 1),
]
c["blob"] = b"\x0a\x07\x08\x09\x15\x7b\x00\x00\x00"
c["values"] = {"inner": {"x": -5, "y": 123}}
CASES.append(c)


"""
# Repeated scalars case (packed numeric, plus strings/bytes).

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > repeated_scalars.proto <<'PROTO'
syntax = "proto3";
package testpb;
message RepeatedScalars {
  repeated uint64 ids = 1;
  repeated string tags = 2;
  repeated bytes blobs = 3;
  repeated sint64 nums = 4;
}
PROTO
protoc --python_out=. repeated_scalars.proto
python3 - <<'PY'
import repeated_scalars_pb2
m = repeated_scalars_pb2.RepeatedScalars(
    ids=[7,8,9], tags=["a","bb","ccc"], blobs=[b"x", b"yz"], nums=[-1,2,-3]
)
b = m.SerializeToString()
print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')
PY
"""
c = {}
c["name"] = "repeated_scalars"
c["proto"] = '''
syntax = "proto3";
package testpb;
message RepeatedScalars {
  repeated uint64 ids = 1;
  repeated string tags = 2;
  repeated bytes blobs = 3;
  repeated sint64 nums = 4;
}
'''.strip()
c["schema"] = [
    ("repeated", "ids", 1, "varint"),
    ("repeated", "tags", 2, "string"),
    ("repeated", "blobs", 3, "bytes"),
    ("repeated", "nums", 4, "sint"),
]
c["blob"] = b"\x0a\x03\x07\x08\x09\x12\x01\x61\x12\x02\x62\x62\x12\x03\x63\x63\x63\x1a\x01\x78\x1a\x02\x79\x7a\x22\x03\x01\x04\x05"
c["values"] = {
    "ids": [7, 8, 9],
    "tags": ["a", "bb", "ccc"],
    "blobs": [b"x", b"yz"],
    "nums": [-1, 2, -3],
}
CASES.append(c)


"""
# Repeated messages case.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > repeated_messages.proto <<'PROTO'
syntax = "proto3";
package testpb;
message RepeatedMessages {
  message Point { uint64 x = 1; uint64 y = 2; }
  repeated Point pts = 1;
}
PROTO
protoc --python_out=. repeated_messages.proto
python3 - <<'PY'
import repeated_messages_pb2
m = repeated_messages_pb2.RepeatedMessages(
    pts=[
        repeated_messages_pb2.RepeatedMessages.Point(x=1, y=2),
        repeated_messages_pb2.RepeatedMessages.Point(x=3, y=4),
    ]
)
b = m.SerializeToString()
print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')
PY
"""
c = {}
c["name"] = "repeated_messages"
c["proto"] = '''
syntax = "proto3";
package testpb;
message RepeatedMessages {
  message Point { uint64 x = 1; uint64 y = 2; }
  repeated Point pts = 1;
}
'''.strip()
c["schema"] = [
    ("repeated", "pts", 1, [
        ("varint", "x", 1),
        ("varint", "y", 2),
    ]),
]
c["blob"] = b"\x0a\x04\x08\x01\x10\x02\x0a\x04\x08\x03\x10\x04"
c["values"] = {"pts": [{"x": 1, "y": 2}, {"x": 3, "y": 4}]}
CASES.append(c)


"""
# Packed fixed-width numeric case (proto3 packed).

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > packed_fixed.proto <<'PROTO'
syntax = "proto3";
package testpb;
message PackedFixed {
  repeated fixed32 f32s = 1;
  repeated fixed64 f64s = 2;
}
PROTO
protoc --python_out=. packed_fixed.proto
python3 - <<'PY'
import packed_fixed_pb2
m = packed_fixed_pb2.PackedFixed(f32s=[0, 1, 0xffffffff], f64s=[0, 1, 0xffffffffffffffff])
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "packed_fixed"
c["proto"] = '''
syntax = "proto3";
package testpb;
message PackedFixed {
  repeated fixed32 f32s = 1;
  repeated fixed64 f64s = 2;
}
'''.strip()
c["schema"] = [
    ("repeated", "f32s", 1, "fixed32"),
    ("repeated", "f64s", 2, "fixed64"),
]
c["blob"] = b"\x0a\x0c\x00\x00\x00\x00\x01\x00\x00\x00\xff\xff\xff\xff\x12\x18\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff"
c["values"] = {
    "f32s": [0, 1, 0xffffffff],
    "f64s": [0, 1, 0xffffffffffffffff],
}
CASES.append(c)

"""
# Unicode strings and empty fields (proto3 omits defaults).

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > unicode.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Unicode {
  string s1 = 1;
  string s2 = 2;
  bytes b1 = 3;
}
PROTO
protoc --python_out=. unicode.proto
python3 - <<'PY'
import unicode_pb2
m = unicode_pb2.Unicode(s1="héllo Ω🚀", s2="", b1=b"")
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "unicode"
c["proto"] = '''
syntax = "proto3";
package testpb;
message Unicode {
  string s1 = 1;
  string s2 = 2;
  bytes b1 = 3;
}
'''.strip()
c["schema"] = [
    ("string", "s1", 1),
    ("string", "s2", 2),
    ("bytes", "b1", 3),
]
# Only s1 is present in wire; s2/b1 omitted as defaults
c["blob"] = b"\x0a\x0d\x68\xc3\xa9\x6c\x6c\x6f\x20\xce\xa9\xf0\x9f\x9a\x80"
c["values"] = {"s1": "héllo Ω🚀"}
CASES.append(c)


"""
# Boundary values for varint/sint/fixed32/fixed64.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > bounds.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Bounds {
  uint64 u = 1;
  sint64 s = 2;
  fixed32 f32 = 3;
  fixed64 f64 = 4;
}
PROTO
protoc --python_out=. bounds.proto
python3 - <<'PY'
import bounds_pb2
m = bounds_pb2.Bounds(u=2**64-1, s=-(2**63), f32=0xffffffff, f64=0xffffffffffffffff)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "bounds"
c["proto"] = '''
syntax = "proto3";
package testpb;
message Bounds {
  uint64 u = 1;
  sint64 s = 2;
  fixed32 f32 = 3;
  fixed64 f64 = 4;
}
'''.strip()
c["schema"] = [
    ("varint", "u", 1),
    ("sint", "s", 2),
    ("fixed32", "f32", 3),
    ("fixed64", "f64", 4),
]
c["blob"] = b"\x08\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x1d\xff\xff\xff\xff\x21\xff\xff\xff\xff\xff\xff\xff\xff"
c["values"] = {
    "u": 2**64 - 1,
    "s": -(2**63),
    "f32": 0xffffffff,
    "f64": 0xffffffffffffffff,
}
CASES.append(c)


"""
# Deeper nesting: three levels A{B{C{...}}} with repeats.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > deep_nest.proto <<'PROTO'
syntax = "proto3";
package testpb;
message C { sint64 z = 1; fixed32 f = 2; }
message B { uint64 y = 1; repeated C cs = 2; }
message A { uint64 x = 1; B b = 2; repeated C tail = 3; }
message Outer { A a = 1; }
PROTO
protoc --python_out=. deep_nest.proto
python3 - <<'PY'
import deep_nest_pb2
c1 = deep_nest_pb2.C(z=-1, f=10)
c2 = deep_nest_pb2.C(z=3, f=20)
c3 = deep_nest_pb2.C(z=5, f=30)
b = deep_nest_pb2.B(y=2, cs=[c1, c2])
a = deep_nest_pb2.A(x=1, b=b, tail=[c3])
m = deep_nest_pb2.Outer(a=a)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
c = {}
c["name"] = "deep_nesting"
c["proto"] = '''
syntax = "proto3";
package testpb;
message C { sint64 z = 1; fixed32 f = 2; }
message B { uint64 y = 1; repeated C cs = 2; }
message A { uint64 x = 1; B b = 2; repeated C tail = 3; }
message Outer { A a = 1; }
'''.strip()
c["schema"] = [
    ([
        ("varint", "x", 1),
        ([
            ("varint", "y", 1),
            ("repeated", "cs", 2, [
                ("sint", "z", 1),
                ("fixed32", "f", 2),
            ]),
        ], "b", 2),
        ("repeated", "tail", 3, [
            ("sint", "z", 1),
            ("fixed32", "f", 2),
        ]),
    ], "a", 1),
]
c["blob"] = b"\x0a\x21\x08\x01\x12\x14\x08\x02\x12\x07\x08\x01\x15\x0a\x00\x00\x00\x12\x07\x08\x06\x15\x14\x00\x00\x00\x1a\x07\x08\x0a\x15\x1e\x00\x00\x00"
c["values"] = {
    "a": {
        "x": 1,
        "b": {
            "y": 2,
            "cs": [
                {"z": -1, "f": 10},
                {"z": 3, "f": 20},
            ],
        },
        "tail": [
            {"z": 5, "f": 30},
        ],
    }
}
CASES.append(c)


_CASE_IDS = [c["name"] for c in CASES]


@pytest.mark.parametrize("case", CASES, ids=_CASE_IDS)
def test_decode_official(case):
    # Decode official bytes and compare to canonical values
    dec = pb.decode(case["blob"], case["schema"])
    assert dec == case["values"], case["proto"]


@pytest.mark.parametrize("case", CASES, ids=_CASE_IDS)
def test_encode_official(case):
    # Encode canonical values and compare to official bytes
    enc = pb.encode(case["values"], case["schema"])
    assert enc == case["blob"], case["proto"]


def _sorted_by_key(entries):
    return sorted(entries, key=lambda d: d["key"]) if isinstance(entries, list) else entries


"""
# Mixed keys repro: official golden from MixedKeys proto

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > mixed_keys.proto <<'PROTO'
syntax = "proto3";
package testpb;
message MixedKeys { uint64 id = 1; string name = 2; bytes raw = 3; }
PROTO
protoc --python_out=. mixed_keys.proto
python3 - <<'PY'
import mixed_keys_pb2
m = mixed_keys_pb2.MixedKeys(id=7, name="ok", raw=b"xy")
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
def test_encode_mixed_keys_matches_official():
    #
    # Arrange
    #
    schema = [("varint", "id", 1), ("string", "name", 2), ("bytes", "raw", 3)]
    blob = b"\x08\x07\x12\x02\x6f\x6b\x1a\x02\x78\x79"
    values_mixed = {"id": 7, 2: "ok", 3: b"xy"}

    #
    # Act
    #
    enc = pb.encode(values_mixed, schema)

    #
    # Assert
    #
    assert enc == blob


"""
# Maps-as-entries (non-deterministic official ordering)

# The official Python protobuf runtime may not produce a stable ordering for
# map entries across versions or platforms. This makes bitwise-equality tests
# flaky. Instead of including this in CASES, we provide standalone decode and
# roundtrip tests below, and accept both common orderings for payloads.

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > maps.proto <<'PROTO'
syntax = "proto3";
package testpb;
message WithMap {
  map<string, sint64> scores = 1;
  map<uint64, bytes> payloads = 2;
}
PROTO
protoc --python_out=. maps.proto
python3 - <<'PY'
import maps_pb2
m = maps_pb2.WithMap()
m.scores["alice"] = -1
m.scores["bob"] = 42
m.payloads[1] = b"x"
m.payloads[2] = b"\x00\x01"  # two raw bytes 00 01
b = m.SerializeToString()
print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')
PY
"""

MAPS_SCHEMA = [
    ("repeated", "scores", 1, [("string", "key", 1), ("sint", "value", 2)]),
    ("repeated", "payloads", 2, [("varint", "key", 1), ("bytes", "value", 2)]),
]
MAPS_EXPECTED = {
    "scores": [
        {"key": "alice", "value": -1},
        {"key": "bob", "value": 42},
    ],
    "payloads": [
        {"key": 1, "value": b"x"},
        {"key": 2, "value": b"\x00\x01"},
    ],
}

# Two observed orderings for payloads in official output
MAPS_BLOB_A = b"\x0a\x07\x0a\x03\x62\x6f\x62\x10\x54\x0a\x09\x0a\x05\x61\x6c\x69\x63\x65\x10\x01\x12\x06\x08\x02\x12\x02\x00\x01\x12\x05\x08\x01\x12\x01\x78"
MAPS_BLOB_B = b"\x0a\x09\x0a\x05\x61\x6c\x69\x63\x65\x10\x01\x0a\x07\x0a\x03\x62\x6f\x62\x10\x54\x12\x06\x08\x02\x12\x02\x00\x01\x12\x05\x08\x01\x12\x01\x78"



def test_maps_as_entries_decode_official_variants():
    #
    # Arrange
    #
    blobs = [MAPS_BLOB_A, MAPS_BLOB_B]

    #
    # Act + Assert
    #
    for blob in blobs:
        dec = pb.decode(blob, MAPS_SCHEMA)
        # Compare after sorting entries by key to ignore ordering
        assert _sorted_by_key(dec["scores"]) == MAPS_EXPECTED["scores"]
        assert _sorted_by_key(dec["payloads"]) == MAPS_EXPECTED["payloads"]


def test_maps_as_entries_encode_roundtrip_stable_values():
    #
    # Arrange
    #
    values = MAPS_EXPECTED

    #
    # Act
    #
    enc = pb.encode(values, MAPS_SCHEMA)
    dec = pb.decode(enc, MAPS_SCHEMA)

    #
    # Assert
    #
    assert _sorted_by_key(dec["scores"]) == MAPS_EXPECTED["scores"]
    assert _sorted_by_key(dec["payloads"]) == MAPS_EXPECTED["payloads"]


# Decode tolerance: multiple packed segments for the same repeated field.
def test_decode_multiple_packed_segments_merges():
    #
    # Arrange
    #
    schema = [("repeated", "ids", 1, "varint")]

    # key=0x0a (field1,len), [1,2], then another packed [3]
    wire = b"\x0a\x02\x01\x02\x0a\x01\x03"

    #
    # Act
    #
    dec = pb.decode(wire, schema)

    #
    # Assert
    #
    assert dec["ids"] == [1, 2, 3]


# Decode tolerance: unpacked repeated numerics (wire type 0 used repeatedly).
def test_decode_unpacked_repeated_numeric():
    #
    # Arrange
    #
    schema = [("repeated", "ids", 1, "varint")]

    # key=0x08 (field1,varint), values 7,8,9
    wire = b"\x08\x07\x08\x08\x08\x09"

    #
    # Act
    #
    dec = pb.decode(wire, schema)

    #
    # Assert
    #
    assert dec["ids"] == [7, 8, 9]


# Decode tolerance: out-of-order tags still decode correctly.
def test_decode_out_of_order_tags():
    #
    # Arrange
    #
    schema = [("varint", "id", 1), ("string", "name", 2), ("bytes", "raw", 3)]

    # order: raw=3, id=1, name=2
    wire = b"\x1a\x02xy\x08\x07\x12\x02ok"

    #
    # Act
    #
    dec = pb.decode(wire, schema)

    #
    # Assert
    #
    assert dec == {"id": 7, "name": "ok", "raw": b"xy"}


# Decode tolerance: mix unpacked and packed segments for the same field.
def test_decode_mixed_packed_and_unpacked_segments():
    #
    # Arrange
    #
    schema = [("repeated", "ids", 1, "varint")]
    # Unpacked 1,2 then a packed segment [3,4]
    wire = b"\x08\x01\x08\x02\x0a\x02\x03\x04"

    #
    # Act
    #
    dec = pb.decode(wire, schema)

    #
    # Assert
    #
    assert dec["ids"] == [1, 2, 3, 4]


# Decode tolerance: duplicate singleton; last-wins semantics.
"""
# Duplicate singleton last-wins repro (decode-only):

# This wire is crafted by concatenating two serialized messages of the same
# type, which the protobuf wire format permits and decoders treat as one
# message where the later field overwrites the earlier one.

# Repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > dup_singleton.proto <<'PROTO'
syntax = "proto3";
package testpb;
message One { uint64 id = 1; }
PROTO
protoc --python_out=. dup_singleton.proto
python3 - <<'PY'
import dup_singleton_pb2
m1 = dup_singleton_pb2.One(id=1)
m2 = dup_singleton_pb2.One(id=2)
b = m1.SerializeToString() + m2.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
def test_decode_duplicate_singleton_last_wins():
    #
    # Arrange
    #
    schema = [("varint", "id", 1)]
    # two occurrences of field 1 (varint): 1 then 2
    wire = b"\x08\x01\x08\x02"

    #
    # Act
    #
    dec = pb.decode(wire, schema)

    #
    # Assert
    #
    assert dec == {"id": 2}


"""
# Out-of-order + duplicates combined (decode-only tolerance)

# We construct a wire by concatenating partial messages to achieve both
# out-of-order fields and a duplicated singleton with last-wins semantics.

# Repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > partials.proto <<'PROTO'
syntax = "proto3";
package testpb;
message P { uint64 id = 1; string name = 2; bytes raw = 3; }
PROTO
protoc --python_out=. partials.proto
python3 - <<'PY'
import partials_pb2
b = b''
b += partials_pb2.P(name='ok').SerializeToString()      # name first
b += partials_pb2.P(id=1).SerializeToString()           # id=1
b += partials_pb2.P(raw=b'x').SerializeToString()       # raw next
b += partials_pb2.P(id=2).SerializeToString()           # id again (last-wins)
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
def test_decode_out_of_order_with_duplicate_last_wins():
    #
    # Arrange
    #
    schema = [("varint", "id", 1), ("string", "name", 2), ("bytes", "raw", 3)]
    wire = b"\x12\x02\x6f\x6b\x08\x01\x1a\x01\x78\x08\x02"

    #
    # Act
    #
    dec = pb.decode(wire, schema)

    #
    # Assert
    #
    assert dec == {"id": 2, "name": "ok", "raw": b"x"}


"""
# Unknown fields case.

# Golden bits repro steps (prints three buffers):
tmp=$(mktemp -d); cd "$tmp"
cat > mixed.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Mixed {
  uint64 a = 1;
  uint64 mystery = 100;
}
PROTO
protoc --python_out=. mixed.proto
python3 - <<'PY'
import mixed_pb2
def dump(m, name):
    b=m.SerializeToString()
    print(name+':')
    print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')

dump(mixed_pb2.Mixed(a=7, mystery=42), 'ORIG')
dump(mixed_pb2.Mixed(a=8, mystery=42), 'KNOWN_CHANGED')
dump(mixed_pb2.Mixed(a=7, mystery=77), 'UNKNOWN_CHANGED')
PY
"""
UNK_SCHEMA_REDUCED = [("varint", "a", 1)]
UNK_SCHEMA_FULL = [("varint", "a", 1), ("varint", "mystery", 100)]
UNK_ORIG = b"\x08\x07\xa0\x06\x2a"
UNK_GOLD_KNOWN_CHANGED = b"\x08\x08\xa0\x06\x2a"
UNK_GOLD_UNKNOWN_CHANGED = b"\x08\x07\xa0\x06\x4d"


def test_unknown_fields_preserved_when_changing_known():
    #
    # Act
    #
    dec = pb.decode(UNK_ORIG, UNK_SCHEMA_REDUCED)
    dec["a"] = 8  # modify only known field
    # Re-encode with full schema, keeping unknown (tag 100) from decode
    values = {"a": dec["a"], 100: dec[100]}
    enc = pb.encode(values, UNK_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == UNK_GOLD_KNOWN_CHANGED


def test_unknown_field_can_be_modified_and_roundtrips():
    #
    # Act
    #
    dec = pb.decode(UNK_ORIG, UNK_SCHEMA_REDUCED)
    # modify unknown tag value (stored as numeric key)
    dec[100] = 77
    values = {"a": dec["a"], "mystery": dec[100]}
    enc = pb.encode(values, UNK_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == UNK_GOLD_UNKNOWN_CHANGED


"""
# Unknown length-delimited fields case.

# Golden bits repro steps (prints three buffers):
tmp=$(mktemp -d); cd "$tmp"
cat > mixed_ld.proto <<'PROTO'
syntax = "proto3";
package testpb;
message MixedLD {
  uint64 a = 1;
  bytes mystery = 100;
}
PROTO
protoc --python_out=. mixed_ld.proto
python3 - <<'PY'
import mixed_ld_pb2
def dump(m, name):
    b=m.SerializeToString()
    print(name+':')
    print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')

dump(mixed_ld_pb2.MixedLD(a=7, mystery=b"\x01\x02\x03"), 'ORIG')
dump(mixed_ld_pb2.MixedLD(a=8, mystery=b"\x01\x02\x03"), 'KNOWN_CHANGED')
dump(mixed_ld_pb2.MixedLD(a=7, mystery=b"\xff"), 'UNKNOWN_CHANGED')
PY
"""
UNKLD_SCHEMA_REDUCED = [("varint", "a", 1)]
UNKLD_SCHEMA_FULL = [("varint", "a", 1), ("bytes", "mystery", 100)]
UNKLD_ORIG = b"\x08\x07\xa2\x06\x03\x01\x02\x03"
UNKLD_GOLD_KNOWN_CHANGED = b"\x08\x08\xa2\x06\x03\x01\x02\x03"
UNKLD_GOLD_UNKNOWN_CHANGED = b"\x08\x07\xa2\x06\x01\xff"


def test_unknown_len_delim_preserved_when_changing_known():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(UNKLD_ORIG, UNKLD_SCHEMA_REDUCED)
    dec["a"] = 8  # modify only known field
    # Re-encode with full schema, keeping unknown (tag 100) from decode
    values = {"a": dec["a"], 100: dec[100]}
    enc = pb.encode(values, UNKLD_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == UNKLD_GOLD_KNOWN_CHANGED


def test_unknown_len_delim_can_be_modified_and_roundtrips():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(UNKLD_ORIG, UNKLD_SCHEMA_REDUCED)
    # modify unknown bytes (stored as numeric key 100)
    dec[100] = b"\xff"
    values = {"a": dec["a"], "mystery": dec[100]}
    enc = pb.encode(values, UNKLD_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == UNKLD_GOLD_UNKNOWN_CHANGED


"""
# Unknown fixed32 fields case.

# Golden bits repro steps (prints three buffers):
tmp=$(mktemp -d); cd "$tmp"
cat > mixed_f32.proto <<'PROTO'
syntax = "proto3";
package testpb;
message MixedF32 {
  uint64 a = 1;
  fixed32 mystery = 100;
}
PROTO
protoc --python_out=. mixed_f32.proto
python3 - <<'PY'
import mixed_f32_pb2
print('ORIG:')
print('b"' + ''.join(f'\\x{c:02x}' for c in mixed_f32_pb2.MixedF32(a=7, mystery=0x0d0c0b0a).SerializeToString()) + '"')
print('KNOWN_CHANGED:')
print('b"' + ''.join(f'\\x{c:02x}' for c in mixed_f32_pb2.MixedF32(a=8, mystery=0x0d0c0b0a).SerializeToString()) + '"')
print('UNKNOWN_CHANGED:')
print('b"' + ''.join(f'\\x{c:02x}' for c in mixed_f32_pb2.MixedF32(a=7, mystery=0x11223344).SerializeToString()) + '"')
PY
"""
UNK32_SCHEMA_REDUCED = [("varint", "a", 1)]
UNK32_SCHEMA_FULL = [("varint", "a", 1), ("fixed32", "mystery", 100)]
UNK32_ORIG = b"\x08\x07\xa5\x06\x0a\x0b\x0c\x0d"
UNK32_GOLD_KNOWN_CHANGED = b"\x08\x08\xa5\x06\x0a\x0b\x0c\x0d"
UNK32_GOLD_UNKNOWN_CHANGED = b"\x08\x07\xa5\x06\x44\x33\x22\x11"


def test_unknown_fixed32_preserved_when_changing_known():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(UNK32_ORIG, UNK32_SCHEMA_REDUCED)
    dec["a"] = 8
    values = {"a": dec["a"], 100: dec[100]}
    enc = pb.encode(values, UNK32_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == UNK32_GOLD_KNOWN_CHANGED


def test_unknown_fixed32_can_be_modified_and_roundtrips():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(UNK32_ORIG, UNK32_SCHEMA_REDUCED)
    dec[100] = 0x11223344
    values = {"a": dec["a"], "mystery": dec[100]}
    enc = pb.encode(values, UNK32_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == UNK32_GOLD_UNKNOWN_CHANGED


"""
# Unknown fixed64 fields case.

# Golden bits repro steps (prints three buffers):
tmp=$(mktemp -d); cd "$tmp"
cat > mixed_f64.proto <<'PROTO'
syntax = "proto3";
package testpb;
message MixedF64 {
  uint64 a = 1;
  fixed64 mystery = 100;
}
PROTO
protoc --python_out=. mixed_f64.proto
python3 - <<'PY'
import mixed_f64_pb2
print('ORIG:')
print('b"' + ''.join(f'\\x{c:02x}' for c in mixed_f64_pb2.MixedF64(a=7, mystery=0x0807060504030201).SerializeToString()) + '"')
print('KNOWN_CHANGED:')
print('b"' + ''.join(f'\\x{c:02x}' for c in mixed_f64_pb2.MixedF64(a=8, mystery=0x0807060504030201).SerializeToString()) + '"')
print('UNKNOWN_CHANGED:')
print('b"' + ''.join(f'\\x{c:02x}' for c in mixed_f64_pb2.MixedF64(a=7, mystery=0x1122334455667788).SerializeToString()) + '"')
PY
"""
UNK64_SCHEMA_REDUCED = [("varint", "a", 1)]
UNK64_SCHEMA_FULL = [("varint", "a", 1), ("fixed64", "mystery", 100)]
UNK64_ORIG = b"\x08\x07\xa1\x06\x01\x02\x03\x04\x05\x06\x07\x08"
UNK64_GOLD_KNOWN_CHANGED = b"\x08\x08\xa1\x06\x01\x02\x03\x04\x05\x06\x07\x08"
UNK64_GOLD_UNKNOWN_CHANGED = b"\x08\x07\xa1\x06\x88\x77\x66\x55\x44\x33\x22\x11"


def test_unknown_fixed64_preserved_when_changing_known():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(UNK64_ORIG, UNK64_SCHEMA_REDUCED)
    dec["a"] = 8
    values = {"a": dec["a"], 100: dec[100]}
    enc = pb.encode(values, UNK64_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == UNK64_GOLD_KNOWN_CHANGED


def test_unknown_fixed64_can_be_modified_and_roundtrips():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(UNK64_ORIG, UNK64_SCHEMA_REDUCED)
    dec[100] = 0x1122334455667788
    values = {"a": dec["a"], "mystery": dec[100]}
    enc = pb.encode(values, UNK64_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == UNK64_GOLD_UNKNOWN_CHANGED


"""
# Repeated unknown fields preserve order (varint and bytes)

# Golden bits repro steps (prints two buffers):
tmp=$(mktemp -d); cd "$tmp"
cat > mixed_rep.proto <<'PROTO'
syntax = "proto3";
package testpb;
message MixedRep { uint64 a = 1; repeated uint64 mystery = 100; }
PROTO
protoc --python_out=. mixed_rep.proto
python3 - <<'PY'
import mixed_rep_pb2
print('VARINT:')
print('b"' + ''.join(f'\\x{c:02x}' for c in mixed_rep_pb2.MixedRep(a=7, mystery=[1, 42]).SerializeToString()) + '"')
PY
cat > mixed_rep_ld.proto <<'PROTO'
syntax = "proto3";
package testpb;
message MixedRepLD { uint64 a = 1; repeated bytes mystery = 101; }
PROTO
protoc --python_out=. mixed_rep_ld.proto
python3 - <<'PY'
import mixed_rep_ld_pb2
print('BYTES:')
print('b"' + ''.join(f'\\x{c:02x}' for c in mixed_rep_ld_pb2.MixedRepLD(a=7, mystery=[b"X", b"YZ"]).SerializeToString()) + '"')
PY
"""
UNKREP_SCHEMA_REDUCED = [("varint", "a", 1)]
UNKREP_SCHEMA_FULL_VARINT = [("varint", "a", 1), ("repeated", "mystery", 100, "varint")]
UNKREP_SCHEMA_FULL_BYTES = [("varint", "a", 1), ("repeated", "mystery", 101, "bytes")]
UNKREP_VARINT_ORIG = b"\x08\x07\xa2\x06\x02\x01\x2a"
UNKREP_BYTES_ORIG = b"\x08\x07\xaa\x06\x01\x58\xaa\x06\x02\x59\x5a"


def test_repeated_unknown_varint_preserved_order_when_roundtripped():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(UNKREP_VARINT_ORIG, UNKREP_SCHEMA_REDUCED)
    # Unknown field 100 is packed (length-delimited) varints; decode chunk to a list
    packed = dec[100]
    nums = []
    i = 0
    b = packed
    while i < len(b):
        shift = 0
        n = 0
        while True:
            c = b[i]
            i += 1
            n |= (c & 0x7F) << shift
            if not (c & 0x80):
                break
            shift += 7
        nums.append(n)
    values = {"a": dec["a"], "mystery": nums}
    enc = pb.encode(values, UNKREP_SCHEMA_FULL_VARINT)

    #
    # Assert
    #
    assert enc == UNKREP_VARINT_ORIG


def test_repeated_unknown_bytes_preserved_order_when_roundtripped():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(UNKREP_BYTES_ORIG, UNKREP_SCHEMA_REDUCED)
    values = {"a": dec["a"], 101: dec[101]}
    enc = pb.encode(values, UNKREP_SCHEMA_FULL_BYTES)

    #
    # Assert
    #
    assert enc == UNKREP_BYTES_ORIG


"""
# Nested unknowns in an embedded message; preserve while changing known.

# Golden bits repro steps (prints three buffers):
tmp=$(mktemp -d); cd "$tmp"
cat > nested_unknown.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Inner { uint64 x = 1; uint64 mystery = 100; }
message Outer { Inner inner = 1; }
PROTO
protoc --python_out=. nested_unknown.proto
python3 - <<'PY'
import nested_unknown_pb2
def dump(m, name):
    b=m.SerializeToString()
    print(name+':')
    print('b"' + ''.join(f'\\x{c:02x}' for c in b) + '"')

dump(nested_unknown_pb2.Outer(inner=nested_unknown_pb2.Inner(x=7, mystery=42)), 'ORIG')
dump(nested_unknown_pb2.Outer(inner=nested_unknown_pb2.Inner(x=8, mystery=42)), 'KNOWN_CHANGED')
dump(nested_unknown_pb2.Outer(inner=nested_unknown_pb2.Inner(x=7, mystery=77)), 'UNKNOWN_CHANGED')
PY
"""
NESTED_UNK_SCHEMA_REDUCED = [([("varint", "x", 1)], "inner", 1)]
NESTED_UNK_SCHEMA_FULL = [([("varint", "x", 1), ("varint", "mystery", 100)], "inner", 1)]
NESTED_UNK_ORIG = b"\x0a\x05\x08\x07\xa0\x06\x2a"
NESTED_UNK_GOLD_KNOWN_CHANGED = b"\x0a\x05\x08\x08\xa0\x06\x2a"
NESTED_UNK_GOLD_UNKNOWN_CHANGED = b"\x0a\x05\x08\x07\xa0\x06\x4d"


def test_nested_unknowns_preserved_when_changing_known():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(NESTED_UNK_ORIG, NESTED_UNK_SCHEMA_REDUCED)
    dec["inner"]["x"] = 8
    values = {"inner": {"x": dec["inner"]["x"], 100: dec["inner"][100]}}
    enc = pb.encode(values, NESTED_UNK_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == NESTED_UNK_GOLD_KNOWN_CHANGED


def test_nested_unknowns_can_be_modified_and_roundtrips():
    #
    # Arrange
    #
    # Using constants directly

    #
    # Act
    #
    dec = pb.decode(NESTED_UNK_ORIG, NESTED_UNK_SCHEMA_REDUCED)
    dec["inner"][100] = 77
    values = {"inner": {"x": dec["inner"]["x"], "mystery": dec["inner"][100]}}
    enc = pb.encode(values, NESTED_UNK_SCHEMA_FULL)

    #
    # Assert
    #
    assert enc == NESTED_UNK_GOLD_UNKNOWN_CHANGED
def test_encode_varint_negative_raises_valueerror():
    #
    # Arrange
    #
    schema = [("varint", "id", 1)]
    values = {"id": -1}

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.encode(values, schema)


def test_unknown_scalar_type_in_schema_raises_valueerror():
    #
    # Arrange
    #
    bad_schema = [("bogus", "x", 1)]

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.encode({}, bad_schema)


def test_encode_undefined_field_name_raises_keyerror():
    #
    # Arrange
    #
    schema = [("varint", "id", 1)]
    values = {"nope": 7}

    #
    # Act + Assert
    #
    with pytest.raises(KeyError):
        pb.encode(values, schema)


def test_decode_truncated_varint_value_raises_valueerror():
    #
    # Arrange
    #
    schema = [("varint", "id", 1)]
    # key=0x08 (field1,varint), then truncated varint value (0x80 with MSB set)
    wire = b"\x08\x80"

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.decode(wire, schema)


def test_decode_varint_too_long_raises_valueerror():
    #
    # Arrange
    #
    schema = [("varint", "id", 1)]
    # key ok, then 10 continuation bytes => too-long varint
    wire = b"\x08" + b"\x80" * 10

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.decode(wire, schema)


def test_decode_truncated_fixed32_raises_valueerror():
    #
    # Arrange
    #
    schema = [("fixed32", "f", 1)]
    # key=0x0D for field1,fixed32 then only 3 bytes (needs 4)
    wire = b"\x0d\x00\x00\x00"

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.decode(wire, schema)


def test_decode_truncated_fixed64_raises_valueerror():
    #
    # Arrange
    #
    schema = [("fixed64", "f", 1)]
    # key=0x09 for field1,fixed64 then only 7 bytes (needs 8)
    wire = b"\x09\x00\x00\x00\x00\x00\x00\x00"

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.decode(wire, schema)


def test_decode_truncated_length_delimited_raises_valueerror():
    #
    # Arrange
    #
    schema = [("bytes", "raw", 1)]
    # key=0x0A (field1,len), length=5, but only 2 bytes provided
    wire = b"\x0a\x05ab"

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.decode(wire, schema)


def test_decode_excessive_nesting_raises_valueerror():
    #
    # Arrange
    #
    # Build a self-referential schema: Node { Node child = 1; }
    node = {"fields": {}, "names": {}}
    node["fields"][1] = {"kind": "message", "schema": node, "name": "child"}
    node["names"]["child"] = 1
    schema = node

    # Craft a deeply nested wire with only empty child messages: 0x0a 0x00 nested
    def nest_empty(levels):
        chunk = b"\x0a\x00"  # one level: child present with zero-length message
        for _ in range(levels - 1):
            chunk = b"\x0a" + bytes([len(chunk)]) + chunk
        return chunk

    blob = nest_empty(101)

    #
    # Act + Assert
    #
    with pytest.raises(ValueError):
        pb.decode(blob, schema)


"""
# Schema=None decode: numeric and fixed fields

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > bounds.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Bounds {
  uint64 u = 1;
  sint64 s = 2;
  fixed32 f32 = 3;
  fixed64 f64 = 4;
}
PROTO
protoc --python_out=. bounds.proto
python3 - <<'PY'
import bounds_pb2
m = bounds_pb2.Bounds(u=2**64-1, s=-(2**63), f32=0xffffffff, f64=0xffffffffffffffff)
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
def test_decode_without_schema_numeric_and_fixed_types():
    #
    # Arrange
    #
    # bounds case golden (u=max, s=-(2**63) zigzagged, f32=0xffffffff, f64=0xffffffffffffffff)
    wire = b"\x08\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x1d\xff\xff\xff\xff\x21\xff\xff\xff\xff\xff\xff\xff\xff"

    #
    # Act
    #
    dec = pb.decode(wire, schema=None)

    #
    # Assert
    #
    assert set(dec.keys()) == {1, 2, 3, 4}
    # Exact wire-level values (no schema ⇒ no zigzag decode for field 2)
    assert dec[1] == 2**64 - 1
    assert dec[2] == 2**64 - 1  # zigzag(-2**63) as unsigned varint
    assert dec[3] == 0xffffffff
    assert dec[4] == 0xffffffffffffffff


"""
# Schema=None decode: length-delimited bytes

# Golden bits repro steps:
tmp=$(mktemp -d); cd "$tmp"
cat > unicode.proto <<'PROTO'
syntax = "proto3";
package testpb;
message Unicode {
  string s1 = 1;
  string s2 = 2;
  bytes b1 = 3;
}
PROTO
protoc --python_out=. unicode.proto
python3 - <<'PY'
import unicode_pb2
m = unicode_pb2.Unicode(s1="héllo Ω🚀", s2="", b1=b"")
b = m.SerializeToString()
print('b"' + ''.join('\\x%02x' % c for c in b) + '"')
PY
"""
def test_decode_without_schema_length_delimited_bytes():
    #
    # Arrange
    #
    # unicode case golden: field 1 is a UTF-8 string; without schema it decodes to bytes
    wire = b"\x0a\x0d\x68\xc3\xa9\x6c\x6c\x6f\x20\xce\xa9\xf0\x9f\x9a\x80"

    #
    # Act
    #
    dec = pb.decode(wire, schema=None)

    #
    # Assert
    #
    assert set(dec.keys()) == {1}
    expected = b"\x68\xc3\xa9\x6c\x6c\x6f\x20\xce\xa9\xf0\x9f\x9a\x80"
    assert isinstance(dec[1], (bytes, bytearray))
    assert dec[1] == expected


if __name__ == "__main__":
    unittest.main()
